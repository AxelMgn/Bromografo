/********************************/
/** Alessandra Mugoni          **/
/** Timer Bromografo           **/
/** Icarus Team 2016           **/
/********************************/

#include "TimerOne.h"
#include <TM1637Display.h>

// TM1637 pins
#define CLK 4
#define DIO 5

// Default time
#define startSeconds 0
#define startMinutes 1

// Timer status commands
#define START 1
#define STOP 2
#define SET1 3
#define SET0 4
#define MAN 5
#define HOT 6
#define INIT 0

// Led and relay pins 
#define LED1 10
#define LED2 11
#define RELAY_PIN 12

// Display Segments
const uint8_t SEG_DONE[] = {
  SEG_B | SEG_C | SEG_D | SEG_E | SEG_G,           // d
  SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F,   // O
  SEG_C | SEG_E | SEG_G,                           // n
  SEG_A | SEG_D | SEG_E | SEG_F | SEG_G            // E
  };

const uint8_t SEG_ON[] = {
  SEG_G,           // 
  SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F,   // O
  SEG_C | SEG_E | SEG_G,                           // n
  SEG_G            // 
  };

TM1637Display display(CLK, DIO);
uint8_t data[] = { 0xff, 0xff, 0xff, 0xff };
int seconds = startSeconds;
int minutes = startMinutes;

// Interrupt pin   
const byte interruptPin = 2;
volatile byte code0 = LOW;
volatile byte code1 = LOW;
volatile byte code2 = LOW;
uint8_t comando = INIT; 

void setup() {
  Timer1.initialize(1000000);                                             // 1 second period
  Timer1.pwm(9, 512);
  Serial.begin(9600);
  
  pinMode(interruptPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(interruptPin), read_cmd, RISING); // Interrupt 
  
  display.setBrightness(0x0a);
  display.setSegments(SEG_ON);

  pinMode(6,INPUT);
  pinMode(7,INPUT);
  pinMode(8,INPUT);
  
  pinMode(LED1,OUTPUT);
  pinMode(LED2,OUTPUT);
  pinMode(RELAY_PIN,OUTPUT);
  
  digitalWrite(RELAY_PIN,LOW);
}

void loop() {
  switch (comando) {
   case START:                         // Timer starts
    Timer1.attachInterrupt(countdown); 
    break;
   case STOP:                          // Stop and Reset time
   digitalWrite(LED1,LOW);
    seconds = startSeconds; 
    minutes = startMinutes;
    write_data();
    break;
    default:
    break;
  } 
}

// Interrupt function
void read_cmd() {
  code0 = digitalRead(6);                            // Read command 
  code1 = digitalRead(7);
  code2 = digitalRead(8);
  
  if((code0==LOW) && (code1==LOW) && (code2==HIGH)) {
    comando = 1;
    //Serial.println("Start");
    digitalWrite(LED2,LOW);
    digitalWrite(RELAY_PIN,HIGH);
  }
  if((code0==LOW) && (code1==HIGH) && (code2==HIGH)) {
    comando = 2;
    //Serial.println("Stop");
    digitalWrite(LED2,HIGH);
    digitalWrite(RELAY_PIN,LOW);
  }
  if((code0==LOW) && (code1==LOW) && (code2==LOW) && (comando == MAN)) {
    comando = 3;
    //Serial.println("Increment");
    increment();
    delay(2000);
    comando = 5;
  }
  if((code0==LOW) && (code1==HIGH) && (code2==LOW) && (comando == MAN)) {
    comando = 4;
    //Serial.println("Decrement");
    decrement();
    delay(2000);
    comando = 5;
  }
  if((code0==HIGH) && (code1==LOW) && (code2==LOW) && ((comando == STOP) || (comando == INIT))) {
    comando = 5;
    //Serial.println("Manual");
    seconds = 0;
    minutes = 0;
  }
   if((code0==HIGH) && (code1==LOW) && (code2==HIGH) && ((comando != START) || (comando == INIT))) {
    comando = 6;
    //Serial.println("Hot lamp");
    seconds = 20;
    minutes = 0;
    write_data();    
  }
}

// Timer function
void countdown() {
  if(comando == 1) {
    digitalWrite(10, digitalRead(10) ^ 1);
    display.setBrightness(0x0a);
        data[3] = display.encodeDigit(seconds/1 % 10);
        data[2] = display.encodeDigit(seconds/10 % 10);
        data[1] = display.encodeDigit(minutes/1 % 10);
        data[1] = data[1] + 0x80;
        data[0] = display.encodeDigit(minutes/10 % 10);
    if(seconds <= 0) {
      if (minutes <= 0) {
        display.setSegments(SEG_DONE);
        digitalWrite(10,HIGH);
        return;
        } else {
          
            minutes--;
            if (minutes < 10) {
              data[3] = display.encodeDigit(0);
              data[2] = display.encodeDigit(minutes);
              } else {
                  data[1] = display.encodeDigit(minutes/1 % 10);
                  data[1] = data[1] + 0x80;
                  data[0] = display.encodeDigit(minutes/10 % 10);
                }
              data[3] = display.encodeDigit(seconds/1 % 10);
              data[2] = display.encodeDigit(seconds/10 % 10);
              
              seconds = 59;
          }
    } else {
        data[3] = display.encodeDigit(seconds/1 % 10);
        data[2] = display.encodeDigit(seconds/10 % 10);
        data[1] = display.encodeDigit(minutes/1 % 10);
        data[1] = data[1] + 0x80;
        data[0] = display.encodeDigit(minutes/10 % 10);
  
        seconds--;
      }
    display.setSegments(data);
  } 
}

// Set - increment
void increment() {
  if(seconds >= 50) {
    if (minutes >= 59) {
      minutes = 0;
      seconds = 0;
      return;
    }
    seconds = 0;
    minutes++;
    } else {
          seconds = seconds + 10;
        }
//   Serial.print(minutes);
//   Serial.print(" : ");
//   Serial.println(seconds);
  write_data();
  delay(300);
}

// Set - decrement
void decrement() {
  if(seconds == 0) {
    if (minutes <= 0) return; 
    seconds = 50;
    minutes--;
    } else {
          seconds = seconds - 10;
        } 
//   Serial.print(minutes);
//   Serial.print(" : ");
//   Serial.println(seconds);
  write_data();
  delay(300);
}

// Display 
void write_data() {
    data[3] = display.encodeDigit(seconds/1 % 10);
    data[2] = display.encodeDigit(seconds/10 % 10);
    data[1] = display.encodeDigit(minutes/1 % 10);
    data[1] = data[1] + 0x80;
    data[0] = display.encodeDigit(minutes/10 % 10);
    
    display.setSegments(data);
  }
